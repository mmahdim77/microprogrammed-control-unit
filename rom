module rom(input logic [4:0] adr,
output logic [24:0] dout):
    always_comb
        case(adr)
            5'b00000: dout = 25'b00_0_1_0_0_1_0_10_00_10_??_??_00_00001; //Fetch
            5'b00001: dout = 25'b00_0_0_0_0_0_?_10_00_10_??_xx_00_11111; //Decode
            5'b00010: dout = 25'b00_0_0_0_0_0_?_??_00_01_01_??_00_11110; //MemAdr
            5'b00011: dout = 25'b00_0_0_0_0_0_1_00_??_??_??_??_??_00100; //memread
            5'b00100: dout = 25'b00_0_0_1_0_0_?_01_??_??_??_??_??_00000; //memwb
            5'b00101: dout = 25'b00_0_0_0_1_0_1_00_??_??_??_??_??_00000; //memwrite
            5'b01000: dout = 25'b00_0_0_1_0_0_?_00_??_??_??_??_??_00000; //AluWb
            5'b01001: dout = 25'b00_1_0_0_0_0_?_10_00_01_10_??_00_00000; //Branch
			
			//executeR
			5'b00110: dout = 25'b11_0_0_0_0_0_?_??_00_00_??_??_00_01000; //ERADD
			5'b01010: dout = 25'b11_0_0_0_0_0_?_??_00_00_??_??_01_01000; //ERSUB
			5'b01011: dout = 25'b10_0_0_0_0_0_?_??_00_00_??_??_10_01000; //ERAND
			5'b01100: dout = 25'b10_0_0_0_0_0_?_??_00_00_??_??_11_01000; //EROR
            
			//execute I
			5'b00111: dout = 25'b11_0_0_0_0_0_?_??_00_01_00_??_00_01000; //EIADD
			5'b01101: dout = 25'b11_0_0_0_0_0_?_??_00_01_00_??_01_01000; //EISUB
			5'b01110: dout = 25'b10_0_0_0_0_0_?_??_00_01_00_??_10_01000; //EIAND
			5'b01111: dout = 25'b10_0_0_0_0_0_?_??_00_01_00_??_11_01000; //EIOR


        endcase
endmodule
module sequenceLogic    (input  logic  [4:0]  tempNextAdr,
                         input  logic  [1:0]  op,
                         input  logic  [5:0]  func,
                         output logic  [4:0]  realNextAdr
                        );

    logic [4:0] temp10,temp11, tempEI,tempER;

    assign realNextAdr = (tempNextAdr == 5'b11111) ? temp10 : ((tempNextAdr==5'b11110) ? temp11 : tempNextAdr); 
    assign temp10 = (op==2'b01) ? 5'b00010 : (op==2'b10) ? 5'b01001 : (func[5]) ? tempEI : tempER;
    assign temp11 = (func[0]) ? 5'b00011: 5'b00101;
	assign tempEI = (funct[4:1] == 4'b0100 ) ? 5'b00111 : (funct[4:1] == 4'b0100 ) ? 5'b01101 : (funct[4:1] == 4'b0000 ) ? 5'b01110 : 5'b01111 ;
	assign tempER = (funct[4:1] == 4'b0100 ) ? 5'b00110 : (funct[4:1] == 4'b0100 ) ? 5'b01010 : (funct[4:1] == 4'b0000 ) ? 5'b01011 : 5'b01100 ;
endmodule

module PCLogic (input	logic [3:0] Rd,
				input	logic Branch,RegW,
				output	logic pcs);
	logic checkBranch, checkRegW;
	assign pcs = (Rd == 4'b1111) ? checkRegW : checkBranch ;
	assign checkBranch	= (Branch) ? 1'b1 : 1'b0;
	assign checkRegW	= (RegW) ? 1'b1 : 1'b0;
endmodule


module AluDecoder (	input	logic AluOp,
					input	logic [4:0] Funct,
					output	logic [1:0] AluControl, FlagW);
	logic [1:0] functionDetect, flagWDetection;
	
	
	assign AluControl = (AluOp) functionDetect : 2'b00;
	assign functionDetect = (funct[4:1] == 4'b0100 ) ? 2'b00 : (funct[4:1] == 4'b0100 ) ? 2'b01 : (funct[4:1] == 4'b0000 ) ? 2'b10 : 2'b11 ;
	
	assign FlagW = (AluOp) flagWDetection : 2'b00 ;
	assign functionDetect = (funct[4:1] == 4'b0100 ) ? 2'b11 : (funct[4:1] == 4'b0100 ) ? 2'b11 : (funct[4:1] == 4'b0000 ) ? 2'b10 : 2'b10 ;
endmodule

module instrDecoder (	input	logic [1:0] Op
						output	logic [1:0] ImmSrc, RegSrc);
	
	assign RegSrc = (op == 00) ? 2'b00 : (op == 01) ? 2'b 01 : 2'b1? ; //سیگنال مموری شاید اشتباه کرده باشیم
	assign ImmSrc = (op == 00) ? 2'b00 : (op == 01) ? 2'b 01 : 2'b10 ;
endmodule
